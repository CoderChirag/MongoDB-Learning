# Index Builds on Populated Collections

Starting in MongoDB 4.2, index builds use an optimized build process that holds an exclusive lock on the collection at the beginning and end of the index build. The rest of the build process yields to interleaving read and write operations. For a detailed description of index build process and locking behavior, see [Index Build Process](#index-build-process).

Starting in MongoDB 4.4, index builds on a replica set or sharded cluster build simultaneously across all data-bearing replica set members. The primary requires a minimum number of data-bearing voting members (i.e. commit quorum), including itself, that must complete the build before marking the index as ready for use. A "voting" member is any replica set member where `members[n].votes` is greater than 0. See [Index Builds in Replicated Environments](#index-builds-in-replicated-environments) for more information.

## Behavior

### Comparison to Foreground and Background Builds

Previous versions of MongoDB supported building indexes either in the **foreground** or **background**. **Foreground index builds** were fast and produced more efficient index data structures, but required blocking all read-write access to the parent database of the collection being indexed for the duration of the build. **Background index builds** were slower and had less efficient results, but allowed read-write access to the database and its collections during the build process.

Starting in MongoDB 4.2, index builds obtain an exclusive lock on only the collection being indexed during the start and end of the build process to protect metadata changes. The rest of the build process uses the yielding behavior of background index builds to maximize read-write access to the collection during the build. 4.2 index builds still produce efficient index data structures despite the more permissive locking behavior.

The optimized index build performance is at least on par with background index builds. For workloads with few or no updates received during the build process, optimized index builds can be as fast as a foreground index build on that same data.

Use `db.currentOp()` to monitor the progress of ongoing index builds.

MongoDB ignores the background index build option if specified to `createIndexes` or its shell helpers `createIndex()` and `createIndexes()`.

### Constraint Violations During Index Build

For indexes that enforce **constraints** on the collection, such as unique indexes, the `mongod` checks all pre-existing and concurrently-written documents for violations of those constraints after the index build completes. Documents that violate the index constraints can exist during the index build. If any documents violate the index constraints at the end of the build, the `mongod` terminates the build and throws an error.

For example, consider a populated collection `inventory`. An administrator wants to create a unique index on the `product_sku` field. If any documents in the collection have duplicate values for `product_sku`, the index build can still start successfully. If any violations still exist at the end of the build, the `mongod` terminates the build and throws an error.

Similarly, an application can successfully write documents to the `inventory` collection with duplicate values of `product_sku` while the index build is in progress. If any violations still exist at the end of the build, the `mongod` terminates the build and throws an error.

To mitigate the risk of index build failure due to constraint violations:

-   Validate that no documents in the collection violate the index constraints.
-   Stop all writes to the collection from applications that cannot guarantee violation-free write operations.
