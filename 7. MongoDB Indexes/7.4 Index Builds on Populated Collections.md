# Index Builds on Populated Collections

Starting in MongoDB 4.2, index builds use an optimized build process that holds an exclusive lock on the collection at the beginning and end of the index build. The rest of the build process yields to interleaving read and write operations. For a detailed description of index build process and locking behavior, see [Index Build Process](#index-build-process).

Starting in MongoDB 4.4, index builds on a replica set or sharded cluster build simultaneously across all data-bearing replica set members. The primary requires a minimum number of data-bearing voting members (i.e. commit quorum), including itself, that must complete the build before marking the index as ready for use. A "voting" member is any replica set member where `members[n].votes` is greater than 0. See [Index Builds in Replicated Environments](#index-builds-in-replicated-environments) for more information.

## Behavior

### Comparison to Foreground and Background Builds

Previous versions of MongoDB supported building indexes either in the **foreground** or **background**. **Foreground index builds** were fast and produced more efficient index data structures, but required blocking all read-write access to the parent database of the collection being indexed for the duration of the build. **Background index builds** were slower and had less efficient results, but allowed read-write access to the database and its collections during the build process.

Starting in MongoDB 4.2, index builds obtain an exclusive lock on only the collection being indexed during the start and end of the build process to protect metadata changes. The rest of the build process uses the yielding behavior of background index builds to maximize read-write access to the collection during the build. 4.2 index builds still produce efficient index data structures despite the more permissive locking behavior.

The optimized index build performance is at least on par with background index builds. For workloads with few or no updates received during the build process, optimized index builds can be as fast as a foreground index build on that same data.

Use `db.currentOp()` to monitor the progress of ongoing index builds.

MongoDB ignores the background index build option if specified to `createIndexes` or its shell helpers `createIndex()` and `createIndexes()`.

### Constraint Violations During Index Build

For indexes that enforce **constraints** on the collection, such as unique indexes, the `mongod` checks all pre-existing and concurrently-written documents for violations of those constraints after the index build completes. Documents that violate the index constraints can exist during the index build. If any documents violate the index constraints at the end of the build, the `mongod` terminates the build and throws an error.

For example, consider a populated collection `inventory`. An administrator wants to create a unique index on the `product_sku` field. If any documents in the collection have duplicate values for `product_sku`, the index build can still start successfully. If any violations still exist at the end of the build, the `mongod` terminates the build and throws an error.

Similarly, an application can successfully write documents to the `inventory` collection with duplicate values of `product_sku` while the index build is in progress. If any violations still exist at the end of the build, the `mongod` terminates the build and throws an error.

To mitigate the risk of index build failure due to constraint violations:

-   Validate that no documents in the collection violate the index constraints.
-   Stop all writes to the collection from applications that cannot guarantee violation-free write operations.

# Index Build Impact on Database Performance

## Index Builds During Write-Heavy Workloads

Building indexes during time periods where the target collection is under heavy write load can result in reduced write performance and longer index builds.

Consider designating a maintenance window during which applications stop or reduce write operations against the collection. Start the index build during this maintenance window to mitigate the potential negative impact of the build process.

## Insufficient Available System Memory (RAM)

`createIndexes` supports building one or more indexes on a collection. `createIndexes` uses a combination of memory and temporary files on disk to complete index builds. The default limit on memory usage for `createIndexes` is `200 megabytes` (for versions 4.2.3 and later) and `500` (for versions 4.2.2 and earlier), shared between all indexes built using a single `createIndexes` command. Once the memory limit is reached, `createIndexes` uses temporary disk files in a subdirectory named `_tmp` within the `--dbpath` directory to complete the build.

You can override the memory limit by setting the `maxIndexBuildMemoryUsageMegabytes` server parameter. Setting a higher memory limit may result in faster completion of index builds. However, setting this limit too high relative to the unused RAM on your system can result in memory exhaustion and server shutdown.

If the host machine has limited available free RAM, you may need to schedule a maintenance period to increase the total system RAM before you can modify the `mongod` RAM usage.

# Index Builds in Replicated Environments

Starting with MongoDB 4.4, index builds on a replica set or sharded cluster build simultaneously across all data-bearing replica set members. For sharded clusters, the index build occurs only on shards containing data for the collection being indexed. The primary requires a minimum number of data-bearing **voting** members (i.e commit quorum), including itself, that must complete the build before marking the index as ready for use.

The build process is summarized as follows:

-   The primary receives the `createIndexes` command and immediately creates a "startIndexBuild" oplog entry associated with the index build.
-   The secondaries start the index build after they replicate the "startIndexBuild" oplog entry.
-   Each member "votes" to commit the build once it finishes indexing data in the collection.
-   Secondary members continue to process any new write operations into the index while waiting for the primary to confirm a quorum of votes.
-   When the primary has a quorum of votes, it checks for any key constraint violations such as duplicate key errors.
    -   If there are no key constraint violations, the primary completes the index build, marks the index as ready for use, and creates an associated "commitIndexBuild" oplog entry.
    -   If there are any key constraint violations, the index build fails. The primary aborts the index build and creates an associated "abortIndexBuild" oplog entry.
-   The secondaries replicate the "commitIndexBuild" oplog entry and complete the index build.
    <br>
    If the secondaries instead replicate an "abortIndexBuild" oplog entry, they abort the index build and discard the build job.

# Build Failure and Recovery

## Interrupted Index Builds on a Primary `mongod`

Starting in MongoDB 5.0, if the primary `mongod` shuts down cleanly during the index build and the **commitQuorum** is set to the default votingMembers, then the index build progress is saved to disk. The `mongod` automatically recovers the index build when it is restarted and continues from the saved checkpoint. In earlier versions, if the index build was interrupted it had to be restarted from the beginning.

## Interrupted Index Builds on a Secondary `mongod`

Starting in MongoDB 5.0, if a secondary `mongod` shuts down cleanly during the index build and the **commitQuorum** is set to the default votingMembers, then the index build progress is saved to disk. The `mongod` automatically recovers the index build when it is restarted and continues from the saved checkpoint. In earlier versions, if the index build was interrupted it had to be restarted from the beginning.

Prior to MongoDB 4.4, the startup process stalls behind any recovered index builds. The secondary could fall out of sync with the replica set and require resynchronization. Starting in MongoDB 4.4, the mongod can perform the startup process while the recovering index builds.

If you restart the `mongod` as a standalone (i.e. removing or commenting out `replication.replSetName` or omitting `--replSetName`), the `mongod` cannot restart the index build. The build remains in a paused state until it is manually dropped.

## Interrupted Index Builds on Standalone `mongod`

If the `mongod` shuts down during the index build, the index build job and all progress is lost. Restarting the `mongod` does not restart the index build. You must re-issue the `createIndex()` operation to restart the index build.

## Rollbacks during Build Process

Starting in MongoDB 5.0, if a node is rolled back to a prior state during the index build, the index build progress is saved to disk. If there is still work to be done when the rollback concludes, the `mongod` automatically recovers the index build and continues from the saved checkpoint.

Starting in version 4.4, MongoDB can pause an in-progress index build to perform a rollback.

-   If the rollback does not revert the index build, MongoDB restarts the index build after completing the rollback.
-   If the rollback reverts the index build, you must re-create the index or indexes after the rollback completes.
-   Prior to MongoDb 4.4, rollbacks could start only after all in-progress index builds finished.
