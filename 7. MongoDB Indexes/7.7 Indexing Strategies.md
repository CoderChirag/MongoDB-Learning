# Contents

-   [Contents](#contents)
-   [Indexing Strategies](#indexing-strategies)
-   [The ESR (Equality, Sort, Range) Rule](#the-esr-equality-sort-range-rule)
    -   [Equality](#equality)
    -   [Sort](#sort)
    -   [Range](#range)
    -   [Additional Considerations](#additional-considerations)
    -   [Example](#example)

# Indexing Strategies

The best indexes for your application must take a number of factors into account, including the kinds of queries you expect, the ratio of reads to writes, and the amount of free memory on your system.

When developing your indexing strategy you should have a deep understanding of your application's queries. Before you build indexes, map out the types of queries you will run so that you can build indexes that reference those fields. Indexes come with a performance cost, but are more than worth the cost for frequent queries on large data sets. Consider the relative frequency of each query in the application and whether the query justifies an index.

The best overall strategy for designing indexes is to profile a variety of index configurations with data sets similar to the ones you'll be running in production to see which configurations perform best. Inspect the current indexes created for your collections to ensure they are supporting your current and planned queries. If an index is no longer used, drop the index.

Generally, MongoDB only uses one index to fulfill most queries. However, each clause of an $or query may use a different index, and in addition, MongoDB can use an intersection of multiple indexes.

The following sections introduce indexing strategies:

-   **[Use the ESR (Equality, Sort, Range) Rule](#)**
    **The ESR (Equality, Sort, Range) Rule** is a guide to creating indexes that support your queries efficiently.
-   **[Create Indexes to Support Your Queries](#)**
    An index supports a query when the index contains all the fields scanned by the query. Creating indexes that support queries results in greatly increased query performance.
-   **[Use Indexes to Sort Query Results](#)**
    To support efficient queries, use the strategies here when you specify the sequential order and sort order of index fields.
-   **[Ensure Indexes Fit in RAM](#)**
    When your index fits in RAM, the system can avoid reading the index from disk and you get the fastest processing.
-   **[Create Queries that Ensure Selectivity](#)**
    **Selectivity** is the ability of a query to narrow results using the index. Selectivity allows MongoDB to use the index for a larger portion of the work associated with fulfilling the query.

# The ESR (Equality, Sort, Range) Rule

An index that references multiple fields is a **compound index**. **Compound indexes** can dramatically improve query response times.

Index keys correspond to document fields. In most cases, applying the **ESR (Equality, Sort, Range) Rule** to arrange the index keys helps to create a more efficient compound index.

## Equality

**"Equality"** refers to an exact match on a single value. The following exact match queries scan the `cars` collection for documents whose `model` field exactly matches `Cordoba`.

```
db.cars.find( { model: "Cordoba" } )
db.cars.find( { model: { $eq: "Cordoba" } } )
```

Index searches make efficient use of exact matches to limit the number of documents that need to be examined to satisfy a query. Place fields that require exact matches first in your index.

An index may have multiple keys for queries with exact matches. The index keys for equality matches can appear in any order. However, to satisfy an equality match with the index, all of the index keys for exact matches must come before any other index fields. MongoDB's search algorithm eliminates any need to arrange the exact match fields in a particular order.

Exact matches should be selective. To reduce the number of index keys scanned, ensure equality tests eliminate at least 90% of possible document matches.

## Sort

**"Sort"** determines the order for results. Sort follows equality matches because the equality matches reduce the number of documents that need to be sorted. Sorting after the equality matches also allows MongoDB to do a non-blocking sort.

An index can support sort operations when the query fields are a subset of the index keys. Sort operations on a subset of the index keys are only supported if the query includes equality conditions for all of the prefix keys that precede the sort keys. For more information see: Sort and Non-prefix Subset of an Index.

The following example queries the `cars` collection. The output is sorted by `model`:

```
db.cars.find( { manufacturer: "GM" } ).sort( { model: 1 } )
```

To improve query performance, create an index on the `manufacturer` and `model` fields:

```
db.cars.createIndex( { manufacturer: 1, model: 1 } )
```

`manufacturer` is the first key because it is an equality match.

`model` is indexed in the same order ( `1` ) as the query.

## Range

**"Range"** filters scan fields. The scan doesn't require an exact match, which means range filters are loosely bound to index keys. To improve query efficiency, make the range bounds as tight as possible and use equality matches to limit the number of documents that must be scanned.

Range filters resemble the following:

```
db.cars.find( { price: { $gte: 15000} } )
db.cars.find( { age: { $lt: 10 } } )
db.cars.find( { priorAccidents: { $ne: null } } )
```

MongoDB cannot do an index sort on the results of a range filter. Place the range filter after the sort predicate so MongoDB can use a non-blocking index sort.

## Additional Considerations

Inequality operators such as `$ne` or `$nin` are range operators, not equality operators.

`$regex` is a range operator.

`$in` can be an **equality operator** or a **range operator**. When `$in` is used alone, it is an equality operator that does a series of equality matches. `$in` acts like a range operator when it is used with `.sort()`.

## Example

The following query searches the `cars` collection for vehicles manufactured by `Ford` that cost more than `$15,000` dollars. The results are sorted by `model`:

```
db.cars.find(
   {
       manufacturer: 'Ford',
       cost: { $gt: 10000 }
   } ).sort( { model: 1 } )
```

The query contains all the elements of the **ESR Rule**:

-   `manufacturer`: `'Ford'` is an equality based match
-   `cost`: `{ $gt: 10000 }` is a range based match, and
-   `model` is used for sorting

Following the ESR rule, the optimal index for the example query is:

```
{ manufacturer: 1, model: 1, cost: 1 }
```
