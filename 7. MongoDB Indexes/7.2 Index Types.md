# Single Field Indexes

MongoDB provides complete support for indexes on any field in a collection of documents. By default, all collections have an index on the `_id` field, and applications and users may add additional indexes to support important queries and operations.

This section describes ascending/descending indexes on a single field.

![single field indexes](assets/index-ascending.svg)

## Create an Ascending Index on a Single Field

Consider a collection named `records` that holds documents that resemble the following sample document:

```
{
  "_id": ObjectId("570c04a4ad233577f97dc459"),
  "score": 1034,
  "location": { state: "NY", city: "New York" }
}
```

The following operation creates an ascending index on the `score` field of the `records` collection:

```
db.records.createIndex( { score: 1 } )
```

The value of the field in the index specification describes the kind of index for that field. For example, a value of `1` specifies an index that orders items in **ascending** order. A value of `-1` specifies an index that orders items in **descending** order.

The created index will support queries that select on the field score, such as the following:

```
db.records.find( { score: 2 } )
db.records.find( { score: { $gt: 10 } } )
```

## Create an Index on an Embedded Field

You can create indexes on fields within embedded documents, just as you can index top-level fields in documents. Indexes on embedded fields differ from indexes on embedded documents, which include the full content up to the maximum index size of the embedded document in the index. Instead, indexes on embedded fields allow you to use a **"dot notation,"** to introspect into embedded documents.

Consider a collection named `records` that holds documents that resemble the following sample document:

```
{
  "_id": ObjectId("570c04a4ad233577f97dc459"),
  "score": 1034,
  "location": { state: "NY", city: "New York" }
}
```

The following operation creates an index on the `location.state` field:

```
db.records.createIndex( { "location.state": 1 } )
```

The created index will support queries that select on the field `location.state`, such as the following:

```
db.records.find( { "location.state": "CA" } )
db.records.find( { "location.city": "Albany", "location.state": "NY" } )
```

## Create an Index on Embedded Document

You can also create indexes on embedded document as a whole.

Consider a collection named `records` that holds documents that resemble the following sample document:

```
{
  "_id": ObjectId("570c04a4ad233577f97dc459"),
  "score": 1034,
  "location": { state: "NY", city: "New York" }
}
```

The `location` field is an **embedded document**, containing the embedded fields city and state. The following command creates an index on the `location` field as a whole:

```
db.records.createIndex( { location: 1 } )
```

The following query can use the index on the `location` field:

```
db.records.find( { location: { city: "New York", state: "NY" } } )
```

**Note :** Although the query can use the index, the result set does not include the sample document above. When performing equality matches on embedded documents, field order matters and the embedded documents must match exactly.

# Compund Indexes

MongoDB supports compound indexes, where a single index structure holds references to multiple fields (MongoDB imposes a limit of 32 fields for any compound index) within a collection's documents. The following diagram illustrates an example of a compound index on two fields:

![compund indexes](assets/index-compound-key.svg)
Compound indexes can support queries that match on multiple fields.

## Create a Compound Index

To create a compound index use an operation that resembles the following prototype:

```
db.collection.createIndex( { <field1>: <type>, <field2>: <type2>, ... } )
```

The value of the field in the index specification describes the kind of index for that field. For example, a value of `1` specifies an index that orders items in **ascending** order. A value of `-1` specifies an index that orders items in **descending** order.

The order of the indexed fields has a strong impact on the effectiveness of a particular index for a given query. For most compound indexes, following the **ESR (Equality, Sort, Range) rule** helps to create efficient indexes.

Consider a collection named `products` that holds documents that resemble the following document:

```
{
 "_id": ObjectId(...),
 "item": "Banana",
 "category": ["food", "produce", "grocery"],
 "location": "4th Street Store",
 "stock": 4,
 "type": "cases"
}
```

The following operation creates an ascending index on the `item` and `stock` fields:

```
db.products.createIndex( { "item": 1, "stock": 1 } )
```

**The order of the fields listed in a compound index is important.** The index will contain references to documents sorted first by the values of the `item` field and, within each value of the `item` field, sorted by values of the `stock` field.

In addition to supporting queries that match on all the index fields, compound indexes can support queries that match on the **prefix** of the index fields. That is, the index supports queries on the `item` field as well as both `item` and `stock` fields:

```
db.products.find( { item: "Banana" } )
db.products.find( { item: "Banana", stock: { $gt: 5 } } )
```

## Sort Order

Indexes store references to fields in either ascending (`1`) or descending (`-1`) sort order. For single-field indexes, the sort order of keys doesn't matter because MongoDB can traverse the index in either direction. However, for compound indexes, sort order can matter in determining whether the index can support a sort operation.

Consider a collection events that contains documents with the fields `username` and `date`. Applications can issue queries that return results sorted first by **ascending** `username` values and then by **descending** (i.e. more recent to last) `date` values, such as:

```
db.events.find().sort( { username: 1, date: -1 } )
```

or queries that return results sorted first by **descending** `username` values and then by **ascending** `date` values, such as:

```
db.events.find().sort( { username: -1, date: 1 } )
```

The following index can support both these sort operations:

```
db.events.createIndex( { "username" : 1, "date" : -1 } )
```

However, the above index cannot support sorting by **ascending** `username` values and then by **ascending** `date` values, such as the following:

```
db.events.find().sort( { username: 1, date: 1 } )
```

## Prefixes

Index prefixes are the beginning subsets of indexed fields. For example, consider the following compound index:

```
{ "item": 1, "location": 1, "stock": 1 }
```

The index has the following index prefixes:

-   `{ item: 1 }`
-   `{ item: 1, location: 1 }`

For a compound index, MongoDB can use the index to support queries on the index prefixes. As such, MongoDB can use the index for queries on the following fields:

-   the `item` field,
-   the `item` field and the `location` field,
-   the `item` field and the `location` field and the `stock` field.

MongoDB can also use the index to support a query on the `item` and `stock` fields, since the `item` field corresponds to a prefix. However, in this case the index **would not be as efficient** in supporting the query as it would be if the index were on only `item`. Index fields are parsed in order; if a query omits a particular index prefix, it is unable to make use of any index fields that follow that prefix.

Since a query on `item` and `stock` omits the `location` index prefix, it cannot use the `stock` index field which follows `location`. Only the `item` field in the index can support this query.

MongoDB cannot use the index to support queries that include the following fields since without the `item` field, none of the listed fields correspond to a prefix index:

-   the `location` field,
-   the `stock` field, or
-   the `location` and `stock` fields.

If you have a collection that has both a compound index and an index on its prefix (e.g. `{ a: 1, b: 1 }` and `{ a: 1 }`), if neither index has a sparse or unique constraint, then you can remove the index on the prefix (e.g. `{ a: 1 }`). MongoDB will use the compound index in all of the situations that it would have used the prefix index.
