# Unique Indexes

A unique index ensures that the indexed fields do not store duplicate values; i.e. enforces uniqueness for the indexed fields. By default, MongoDB creates a unique index on the `_id` field during the creation of a collection.

## Create a Unique Index

To create a unique index, use the `db.collection.createIndex()` method with the unique option set to `true`.

```
db.collection.createIndex(<key and index type specification>, { unique: true })
```

## Unique Index on a Single Field

For example, to create a unique index on the `user_id` field of the members collection, use the following operation in **mongosh**:

```
db.members.createIndex( { "user_id": 1 }, { unique: true } )
```

## Unique Compound Index

You can also enforce a unique constraint on compound indexes. If you use the unique constraint on a compound index, then MongoDB will enforce uniqueness on the combination of the index key values.

For example, to create a unique index on `groupNumber`, `lastname`, and `firstname` fields of the `members` collection, use the following operation in **mongosh**:

```
db.members.createIndex( { groupNumber: 1, lastname: 1, firstname: 1 }, { unique: true } )
```

The created index enforces uniqueness for the combination of `groupNumber`, `lastname`, and `firstname` values.

For another example, consider a collection with the following document:

```
{ _id: 1, a: [ { loc: "A", qty: 5 }, { qty: 10 } ] }
```

Create a unique compound multikey index on `a.loc` and `a.qty`:

```
db.collection.createIndex( { "a.loc": 1, "a.qty": 1 }, { unique: true } )
```

The unique index permits the insertion of the following documents into the collection since the index enforces uniqueness for the combination of `a.loc` and `a.qty` values:

```
db.collection.insertMany( [
   { _id: 2, a: [ { loc: "A" }, { qty: 5 } ] },
   { _id: 3, a: [ { loc: "A", qty: 10 } ] }
] )
```

## Unique Index and Missing Field

If a document does not have a value for the indexed field in a unique index, the index will store a null value for this document. Because of the unique constraint, MongoDB will only permit one document that lacks the indexed field. If there is more than one document without a value for the indexed field or is missing the indexed field, the index build will fail with a duplicate key error.

For example, a collection has a unique index on `x`:

```
db.collection.createIndex( { "x": 1 }, { unique: true } )
```

The unique index allows the insertion of a document without the field `x` if the collection does not already contain a document missing the field `x`:

```
db.collection.insertOne( { y: 1 } )
```

However, the unique index errors on the insertion of a document without the field `x` if the collection already contains a document missing the field `x`:

```
db.collection.insertOne( { z: 1 } )
```

The operation fails to insert the document because of the violation of the unique constraint on the value of the field `x`:

```
WriteResult({
   "nInserted" : 0,
   "writeError" : {
      "code" : 11000,
      "errmsg" : "E11000 duplicate key error index: test.collection.$a.b_1 dup key: { : null }"
   }
})
```

# Sparse indexes

Sparse indexes only contain entries for documents that have the indexed field, even if the index field contains a null value. The index skips over any document that is missing the indexed field. The index is "sparse" because it does not include all documents of a collection. By contrast, non-sparse indexes contain all documents in a collection, storing null values for those documents that do not contain the indexed field.

**IMPORTANT**

MongoDB provides the option to create **partial indexes**. Partial indexes offer a superset of the functionality of sparse indexes. Partial Indexes should be preferred over sparse indexes.

## Create a Sparse Index

To create a sparse index, use the `db.collection.createIndex()` method with the `sparse` option set to `true`. For example, the following operation in **mongosh** creates a sparse index on the `xmpp_id` field of the `addresses` collection:

```
db.addresses.createIndex( { "xmpp_id": 1 }, { sparse: true } )
```

The index does not index documents that do not include the `xmpp_id` field.

## Behaviour

### sparse Index and Incomplete Results

If a sparse index would result in an incomplete result set for queries and sort operations, MongoDB will not use that index unless a `hint()` explicitly specifies the index.

For example, the query `{ x: { $exists: false } }` will not use a sparse index on the `x` field unless explicitly hinted.

If you include a `hint()` that specifies a sparse index when you perform a `count()` of all documents in a collection (i.e. with an empty query predicate), the sparse index is used even if the sparse index results in an incorrect count.

```
db.collection.insertOne( { _id: 1, y: 1 } );
db.collection.createIndex( { x: 1 }, { sparse: true } );
db.collection.find().hint( { x: 1 } ).count();
```

To obtain the correct count, do not `hint()` with a sparse index when performing a count of all documents in a collection.

```
db.collection.find().count();
db.collection.createIndex( { y: 1 } );
db.collection.find().hint( { y: 1 } ).count();
```

### sparse Compound Indexes

Sparse compound indexes that only contain ascending/descending index keys will index a document as long as the document contains at least one of the keys.

For sparse compound indexes that contain a geospatial key (i.e. 2dsphere, 2d, or geoHaystack index keys) along with ascending/descending index key(s), only the existence of the geospatial field(s) in a document determine whether the index references the document.

For sparse compound indexes that contain text index keys along with ascending/descending index keys, only the existence of the text index field(s) determine whether the index references a document.

### sparse and unique Properties

An index that is **both sparse and unique** prevents collection from having documents with duplicate values for a field but **allows multiple documents that omit the key**.

## Examples

### Create a Sparse Index On A Collection

Consider a collection `scores` that contains the following documents:

```
{ "_id" : ObjectId("523b6e32fb408eea0eec2647"), "userid" : "newbie" }
{ "_id" : ObjectId("523b6e61fb408eea0eec2648"), "userid" : "abby", "score" : 82 }
{ "_id" : ObjectId("523b6e6ffb408eea0eec2649"), "userid" : "nina", "score" : 90 }
```

The collection has a sparse index on the field `score`:

```
db.scores.createIndex( { score: 1 } , { sparse: true } )
```

Then, the following query on the `scores` collection uses the sparse index to return the documents that have the `score` field less than (`$lt`) `90`:

```
db.scores.find( { score: { $lt: 90 } } )
```

Because the document for the userid `"newbie"` does not contain the score `field` and thus does not meet the query criteria, the query can use the sparse index to return the results:

```
{ "_id" : ObjectId("523b6e61fb408eea0eec2648"), "userid" : "abby", "score" : 82 }
```

### Sparse Index On A Collection Cannot Return Complete Results

Consider a collection `scores` that contains the following documents:

```
{ "_id" : ObjectId("523b6e32fb408eea0eec2647"), "userid" : "newbie" }
{ "_id" : ObjectId("523b6e61fb408eea0eec2648"), "userid" : "abby", "score" : 82 }
{ "_id" : ObjectId("523b6e6ffb408eea0eec2649"), "userid" : "nina", "score" : 90 }
```

The collection has a sparse index on the field `score`:

```
db.scores.createIndex( { score: 1 } , { sparse: true } )
```

Because the document for the userid `"newbie"` does not contain the `score` field, the sparse index does not contain an entry for that document.

Consider the following query to return all documents in the `scores` collection, sorted by the `score` field:

```
db.scores.find().sort( { score: -1 } )
```

Even though the sort is by the indexed field, MongoDB will not select the sparse index to fulfill the query in order to return complete results:

```
{ "_id" : ObjectId("523b6e6ffb408eea0eec2649"), "userid" : "nina", "score" : 90 }
{ "_id" : ObjectId("523b6e61fb408eea0eec2648"), "userid" : "abby", "score" : 82 }
{ "_id" : ObjectId("523b6e32fb408eea0eec2647"), "userid" : "newbie" }
```

To use the sparse index, explicitly specify the index with `hint()`:

```
db.scores.find().sort( { score: -1 } ).hint( { score: 1 } )
```

The use of the index results in the return of only those documents with the score field:

```
{ "_id" : ObjectId("523b6e6ffb408eea0eec2649"), "userid" : "nina", "score" : 90 }
{ "_id" : ObjectId("523b6e61fb408eea0eec2648"), "userid" : "abby", "score" : 82 }
```
